---
title:  ffmpeg视频切片转码合并
date:  2019-01-10 15:06:28
tags: 
  - ffmpeg
  - 转码
categories: 
  - 媒体
---

# ffmpeg视频切片转码合并

- **第一步**：原视频切片

```shell
ffmpeg -fflags +genpts -i input.mov -acodec copy -vcodec copy -f segment -segment_time 300 -reset_timestamps 1 -map 0:0 -map 0:1 piece_%03d.mov
```

**-segment_time**: 指定每个切片的大致时长(s)，默认为2

**-reset_timestamps**: 设置每个切片的时间戳从零开始，不设置的话播放起来会有问题

**-map**: 指定提取的通道，比如某些多音轨的视频就会有多个音轨通道，一般0:0和0:1是默认的audio通道和video通道

**-fflags +genpts**：The -fflags +genpts will regenerate the pts timestamps so it loops smoothly, otherwise the time sequence will be incorrect as it loops （-fflags + genpts将重新生成pts时间戳，使其顺利循环，否则时间序列将不正确。*解决.avi格式切片无效的问题*）

目前测试过的视频格式有：mov、avi、mp4、flv、mkv。rmvb格式切片之后只有声音没图像。

------

*注： 之前一直用

```
ffmpeg -i input.avi -acodec copy -vcodec copy -f segment -segment_time 300 -reset_timestamps 1 -map 0:0 -map 0:1 piece_%03d.avi
```

切片，但是其他格式正常，avi却不成功，只会生成一片piece_000.avi。以下记录一下尝试过的解决办法：

#### 第一、`-ss -t`的使用：

[官方文档说明]: https://trac.ffmpeg.org/wiki/Seeking

![](/images/1540950217348.png)

1. -ss放在-i后面的话会比较慢，但是更准确（其实真的很慢，不推荐）
2. -ss放在-i的前面是快寻找。

实践结果：

第1种方法在拼接处会出现掉帧（播放的时候声音正常，但是画面会卡住几秒）

第2种方法在拼接处会出现重复帧（播放时声音正常，但是画面会重复）

寻找解决办法：

1. 添加`-accurate_seek`，按照实践精确分割：	--失败

   ```shell
   ffmpeg -accurate_seek -ss 00:03:00 -i video.mp4 -t 60 -c copy -avoid_negative_ts 1 cut.mp4
   ```

2. 添加`-noaccurate_seek`，会在时间附近的关键帧处进行分割，感觉很靠谱：

   ```shell
   ffmpeg -noaccurate_seek -ss 00:03:00 -i video.mp4 -t 60 -c copy -avoid_negative_ts 1 cut.mp4
   ```

   测试了几个视频，分割转码再合并，观察输出的视频肉眼确实没有看出掉帧问题，声音也正常。然而按照300s切割的视频，播放的时候时间会直接从4:57直接跳到5:00，略过约3s，时间跳三秒但是没看出来掉帧。所以感觉这个方法还是有问题。（此处只是简单测试，并没有深入研究，按理说按照关键帧进行分割是没有问题的，网上很多资料也是说按照关键帧分割）

3. 难道`-noaccurate_seek`参数不靠谱？那么先手动找到视频的关键帧，然后在关键帧的位置分割呢。

   参考`ffprobe -show_frames -pretty input.avi`命令，输出视频关键帧信息，大致是这样：

   ```
   ...
   [FRAME]
   media_type=audio
   stream_index=1
   key_frame=1
   pkt_pts=42984
   pkt_pts_time=0:00:07.164000
   pkt_dts=42984
   pkt_dts_time=0:00:07.164000
   best_effort_timestamp=42984
   best_effort_timestamp_time=0:00:07.164000
   pkt_duration=216
   pkt_duration_time=0:00:00.036000
   pkt_pos=678738
   pkt_size=216 byte
   sample_fmt=fltp
   nb_samples=576
   channels=2
   channel_layout=stereo
   [/FRAME]
   ...
   ```

   找到5分钟左右的关键帧所对应的dts时间：`pkt_dts_time=0:05:00.024000`，然后在此处进行分割：

   ```shell
   ffmpeg -ss 0 -t dts_time -accurate_seek -i cat.avi -c copy -avoid_negative_ts 1 piece_00.avi
   
   ffmpeg -ss dts_time -t dur_time -accurate_seek -i cat.avi -c copy -avoid_negative_ts 1 piece_01.avi
   ```

   然后再转码拼接，观察输出文件。结果和`-noaccurate_seek`效果一样，而且大视频找关键帧非常非常慢。

   这个实践对应一个简单的python实现，素材是一个7分多钟的avi视频，按照5分钟分割，不过代码写得特别简陋，而且参数都写死了，还是附一下吧：

   ```python
   import subprocess as sp
   import re
   
   
   def cut():
       sp1 = sp.Popen("ffprobe -show_frames -pretty cat.avi", shell=True, stdout=sp.PIPE)
   
       flag = False
       cur_time = [0, 0, 0, 0]
       while True:
           line = sp1.stdout.readline().rstrip()
           if not line:
               break
           if str(line).find("key_frame=0") >= 0:
               flag = False
           if str(line).find("key_frame=1") >= 0:
               flag = True
           if flag:
               if str(line).find("pkt_dts_time=") >= 0:
                   flag = False
                   cur_time = parse_time(str(line))
                   if int(cur_time[1])*60 >= 300:
                       break
   
       piece_time = str(cur_time[0]) + ":" + str(cur_time[1]) + ":" + str(cur_time[2]) + "." + str(cur_time[3])[0:3]
       c1 = sp.Popen("ffmpeg -ss 0 -t " + piece_time + " -accurate_seek -i cat.avi -c copy -avoid_negative_ts 1 piece_00.avi", shell=True)
       c2 = sp.Popen("ffmpeg -ss " + piece_time + " -t " + piece_time + " -accurate_seek -i cat.avi -c copy -avoid_negative_ts 1 piece_01.avi", shell=True)
       c1.communicate()
       c2.communicate()
   
       c3 = sp.Popen("ffmpeg -i piece_00.avi -acodec copy -vcodec copy out0.mp4", shell=True)
       c4 = sp.Popen("ffmpeg -i piece_01.avi -acodec copy -vcodec copy out1.mp4", shell=True)
       c3.communicate()
       c4.communicate()
   
       c5 = sp.Popen("touch index.txt", shell=True)
       c5.communicate()
       f = open("index.txt", 'w')
       f.write("file 'out0.mp4'\nfile 'out1.mp4'")
       f.close()
       sp.Popen("ffmpeg -y -f concat -i index.txt -c copy cat-out-1030.mp4", shell=True)
   
   
   def parse_time(line):
       cur_time = re.findall('(\d+)', line)
       return cur_time
   
   
   if __name__ == '__main__':
       cut()
   
   ```

   到此，`-ss -t`的方式正式放弃了，真是各种问题。


#### 第二、`-f segment`的使用：

##### 法一：

.avi格式的视频切片失效，可以将其不重新编码转成.mp4格式再进行切片：

```shell
ffmpeg -i input.avi -c copy input_new.mp4
```

​	此办法成功，因为用的-c copy速度还算可以，但是不能接受先转一次码。

##### 法二：

添加`-re`	--失败

```shell
ffmpeg -re -i input.avi -acodec copy -vcodec copy -f segment -segment_time 300 -reset_timestamps 1 -map 0:0 -map 0:1 piece_%03d.avi
```

##### 法三：

使用`-use_wallclock_as_timestamps 1`	--失败

```shell
ffmpeg -use_wallclock_as_timestamps 1 -i input.avi -acodec copy -vcodec copy -f segment -segment_time 300 -map 0:0 -map 0:1 piece_%03d.avi
```

第二第三两种方法的参数网上都有解释，不赘述了。

**官方文档中，-f segment还可以将视频生成m3u8格式，可用作HLS：

![](/images/1540953744501.png)

------



- **第二步**：转码

最简单的形式：

```shell
ffmpeg -i piece_000.mov -c copy out_000.mp4
```



- **第三步**：合并

新建一个所有分片的索引文件，例如index.txt，内容如下：

```
file 'out_000.mp4'
file 'out_001.mp4'
file 'out_002.mp4'
```

最后执行以下命令将分片合并成一个完整视频：

```shell
ffmpeg -f concat -i index.txt -c copy output.mp4
```

转码和合并更具体的操作可参见官方文档。